#+STARTUP: showall
#+STARTUP: hidestars
#+STARTUP: lognotestate
#+SEQ_TODO: TODO(t) STARTED(s) WAITING(w) | DONE(d) DELEGATED(g) CANCELED(c) NOTE

* Notes
** [2009-08-14 Fri 03:29]
(defmacro mp-ib-fp (name)
  `(funcall check-it ,(eval name)))

** [2009-08-15 Sat 23:51]
   Brief notes to get started with tomorrow:
   - first write module initialization and accessor routines specific
     to the files module.  Test that they work and desired: clean,
     provide the correct output, and is not a leaky  API.  Then,
     generalize as necessary using higher-order functions and macros.
   - Each of the module open functions should check if the 'autoload'
     parameter is set to t when called.  This probably makes sense to
     do as a higher-order function wrapper or a macro.  See what makes
     sense after writing a couple of them.
   - In order to have any other minimal useful functionality, the
     files module must be minimally feature complete, so that should
     be my first priority.  I will use the development of that module
     as the driver for the development of the generic module support
     functions.
   - The following things are supported for registration of modules:
     - open function -- what opens the buffer or buffer(s) for that
       module?  Question - many modules only open a single buffer, and
       thus will only have one applicable open function.  But files
       has both a 'open-all' and 'open-single-not-yet-open'
       functions.  I intend for open-all to be the thing registered
       here, but perhaps there is another thing that should be
       registered.

     - buffer clean up function -- if closing a buffer opened by a
       module requires some clean up, a hook function should be
       registered here.

     - project clean up function -- if some clean up on project close
       should be done, this function should be registered here.

     - keybindings -- any keybindings should be registered that will
       be added to a metaproject minor mode keymap for a given
       project.  This may require making project-specific keymaps or
       having a wrapper around all interactive functions that does a
       check to see if the buffer belongs to a project that is
       configured to use such functionality.

       - How do I handle conflicting modules / functionality from modules?
	 For example, I could have buffer switching and file open
	 functions that uses standard built-in stuff for completion (or no
	 completion at all, just prompting), but then have ido-using
	 versions that would replace them.  I guess these are usually
	 key-bindings issues, and core code would be registered first, so
	 if a keybinding is overwritten, that's an acceptable case.  My
	 keybinding registration needs to handle the conflicts.

   - Each of the functions will be registered to a hash table that
     keys off of the module name.  When a buffer is set up by the
     module, an appropriate hook, if any, will be added buffer-local.

   - So likely order of features to implement:
     - files specific functions, tested by calling manually
     - abstract to general module functions, make sure files module
       isn't broken
     - module registration of hooks and keybindings
     - implementation of Metaproject minor mode
     - high-level project load function that calls config-load and
       then acts upon the module configuration
       - buffer set up and tear down functions
       - interactive version that prompts (without completion) for
         .metaproject file to load and keybinding
     - project close function and keybinding
     - ido module and keybindings:
       - project open using project-dirs
       - buffer switch

   Regarding my upcoming 0.02 release of Metaproject:
   - In order to be considered for release, I think I should have the
     following criteria met:
     - the code should pass checkdoc, elint (with reason), and
       byte-compile with no warnings and errors
     - the following modules should be minimally feature complete:
       - files
	 - loading all, loading a non-opened file belonging to
	   project, specifying files explicitly in the configuration,
	   interactive function to add a file (buffer) to the project,
	   interactive function to remove current buffer from the project
       - magit
	 - magit buffer for project
       - project-buffer-mode
	 - create and switch to project buffer mode
	 - as integrated with the latest pbm as possible (opening
           files from the buffer has the appropriate data set up, etc)
       - ido
	 - appropriate wrappers for opening files, switching buffers
     - Metaproject minor mode properly implemented
     - Appropriate key bindings should be set for all major add-in
       functions.
     - Enough functionality that users can create and configure
       projects by at least calling a series of functions in their
       *scratch* buffers, with no hand editing of .metaproject files
       required.
     - A quick intro for using it should be in the documentation.

   Releasing:
   - tag on github and update the github project page
   - make page on emacswiki and update
   - make page on freshmeat and update
   - announce to gnu.emacs.sources
   - tweet!
   - post announcement to my blog
   - create new branch in git for the <next version>-SNAPSHOT

   Future non-code things to do:
   - short screencast showcasing functionality
   - contact Emacs hacker friends asking for feedback, realizing they
     are all very busy

   I should spend a few minutes each day brainstorming about upcoming
   desirable features, potential issues to research, and future plans.

   A few quick ideas that should be elaborated on later:
   - a project management menu that is similar (perhaps) to the org
     agenda menu showing all available functions for a project.  this
     could be considered the "main project window" and is always open
     for a project while it is open.
     - Actually, I need to think about this as the registration
       functions are written and configuration is loaded.  What is
       lacking, if anything, to generate this menu for project.
   - a combined switch or open buffer function for files
   - should I make a "core" or "metaproject" default module and
     have associated configuration and state stored there or just
     continue to have some top-level state and configuration mixed in
     with module state and configuration?  Should probably be decided
     before the 0.2 release before I get users.
   - if interactive functions that are bound to a project are called
     outside of a project (via M-x) I should probably prompt for an
     open project to call the function on.
   - dired functions for adding files to a project
   - include/exclude/wildcard functionality for specifying files that
     are in a project
   - clean up project-utils similar to what is in magit so that it is
     a lot faster
   - a fancy project creation and configuration wizard [definitely
     long-term plans]

   That's enough brainstorming for one night.  Don't want to get
   myself overwhelmed.  It looks like for a solid 0.2 release, it will
   take at least another week or so of work.  I *might* be able to
   start dog-fooding tomorrow, though likely in a couple of days.

   One last one:
   - what can I automate?
   - and what about automated testing, perhaps like the Baseline
     framework?

* Notes and plans:
** Open project
***  open all files in a project, including project supporting buffers
***  open just project supporting buffers, including:
**** magit status buffer
**** dired at top level dir
**** supporting org-mode file, if defined
**** open shell buffer (ansi-term or eshell) at top-level dir
**** websites to open via browse-url
***  run any project initialization commands, i.e.:
**** open rope project at appropriate dir (top-level?)
**** start SLIME

** Close project
***  Close all associated files and buffers

** Open file in project
***  Methods:
**** ido
**** dired or dired-like
**** speedbar
***  Use defined list of files in project
***  Use all files in project directories
***  Use all files in project directories sans those ignored by git (see git-dired.el)

** Open project among known projects (like magit-status-repos)

** DONE Switch to open project buffer (ido)
   CLOSED: [2009-08-12 Wed 04:15]

** Jump to or open project buffer:
***  magit status
***  dired (top-level, parent, current)
***  org-mode file
***  shell buffer
***  speedbar or dired for all project files

** Add a keyboard sub-map for the buffers in the project that adds:
***  open file in project
*** DONE close project
    CLOSED: [2009-08-12 Wed 04:15]
***  jump to or open project buffer
*** DONE switch to open project buffer
    CLOSED: [2009-08-12 Wed 04:15]

** Refresh project
***  if new files are added to project

** Add file to project
***  current buffer's file
***  prompt for file
***  currently marked file(s) in dired

** Remove file from project
***  current file
***  prompt for file (ido)

** Create empty project

** Grep through files of the project

** Etags

** ibuffer limited to just project files

** compile project

** agenda just for project files

** project-specific bookmarks

** create and elscreen session for the project

** questions:
*** I seem to be limiting the idea of a project of those files under a common sub-directory.
    This might be fine for now, but that doesn't seem to be a reasonable
    limitation.  I should examine where this assumption is made and see
    how to remove it.  i.e., metaproject-get-top-dir

*** It is probably a reasonable assumption that a given file can only
    belong to one open project at a time.  If I want to allow for this,
    how to work around it?

* Todos
** action registry
***  each key in the .metaproject plist is associated with a given
     action
***  these actions are provided by calling a registry function, often
     within an individual emacs module.  this allows for optional
     functionality to be provided and have a minimal stable core
***  at open time, the action registry is looped through, in order
     (should order matter?), and a check is made to see if a
     corresponding value is found in the plist.  if so, the registered
     action function is called with the value in the plist as its
     argument.
***  do I need registration for other events?  probably at least open
     and close.
***  only the basic ones that include default features from emacs
     proper will be included in the core metaproject module.  right
     now, this is simple file opening and closing and perhaps dired.
***  others include: magit, rope, slime, org-mode, shell buffer, etags
*** DONE Add magit buffer to buffer list and project to its local vars
    CLOSED: [2009-05-19 Tue 21:48]

** code clean-up
*** DONE convert the var to a defcustom
    CLOSED: [2009-05-01 Fri 16:33]
*** TODO add docstrings to all "top-level" functions, at minimum
*** DONE convert TODOs and the like from README.markdown to an org-mode file
    CLOSED: [2009-04-29 Wed 16:48]
*** TODO Add descriptions to the top of the .el files
*** TODO Add usage instructions
*** TODO run checkdoc and fix any errors it reports
