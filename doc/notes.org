#+STARTUP: showall
#+STARTUP: hidestars
#+STARTUP: lognotestate
#+SEQ_TODO: TODO(t) STARTED(s) WAITING(w) | DONE(d) DELEGATED(g) CANCELED(c) NOTE

* Notes
** [2009-08-14 Fri 03:29]
(defmacro mp-ib-fp (name)
  `(funcall check-it ,(eval name)))

** [2009-08-15 Sat 23:51]
   Brief notes to get started with tomorrow:
   - first write module initialization and accessor routines specific
     to the files module.  Test that they work and desired: clean,
     provide the correct output, and is not a leaky  API.  Then,
     generalize as necessary using higher-order functions and macros.
   - Each of the module open functions should check if the 'autoload'
     parameter is set to t when called.  This probably makes sense to
     do as a higher-order function wrapper or a macro.  See what makes
     sense after writing a couple of them.
   - In order to have any other minimal useful functionality, the
     files module must be minimally feature complete, so that should
     be my first priority.  I will use the development of that module
     as the driver for the development of the generic module support
     functions.
   - The following things are supported for registration of modules:
     - open function -- what opens the buffer or buffer(s) for that
       module?  Question - many modules only open a single buffer, and
       thus will only have one applicable open function.  But files
       has both a 'open-all' and 'open-single-not-yet-open'
       functions.  I intend for open-all to be the thing registered
       here, but perhaps there is another thing that should be
       registered.

     - buffer clean up function -- if closing a buffer opened by a
       module requires some clean up, a hook function should be
       registered here.

     - project clean up function -- if some clean up on project close
       should be done, this function should be registered here.

     - keybindings -- any keybindings should be registered that will
       be added to a metaproject minor mode keymap for a given
       project.  This may require making project-specific keymaps or
       having a wrapper around all interactive functions that does a
       check to see if the buffer belongs to a project that is
       configured to use such functionality.

       - How do I handle conflicting modules / functionality from modules?
	 For example, I could have buffer switching and file open
	 functions that uses standard built-in stuff for completion (or no
	 completion at all, just prompting), but then have ido-using
	 versions that would replace them.  I guess these are usually
	 key-bindings issues, and core code would be registered first, so
	 if a keybinding is overwritten, that's an acceptable case.  My
	 keybinding registration needs to handle the conflicts.

     - config and state symbols defaults -- modules should register
       the symbols used in config and state and default values for any
       of these.

   - Each of the functions will be registered to a hash table that
     keys off of the module name.  When a buffer is set up by the
     module, an appropriate hook, if any, will be added buffer-local.

   - The config and state defaults will be registered to hash tables
     that key off of the module name for easy look up.  Defining the
     config and state defaults for each module should inherit first
     from the default values found in metaproject-module-default-*.

   - So likely order of features to implement:
     - files specific functions, tested by calling manually
     - abstract to general module functions, make sure files module
       isn't broken
     - module registration of hooks and keybindings
     - implementation of Metaproject minor mode
     - high-level project load function that calls config-load and
       then acts upon the module configuration
       - buffer set up and tear down functions
       - interactive version that prompts (without completion) for
         .metaproject file to load and keybinding
     - project close function and keybinding
     - ido module and keybindings:
       - project open using project-dirs
       - buffer switch

   Regarding my upcoming 0.02 release of Metaproject:
   - In order to be considered for release, I think I should have the
     following criteria met:
     - the code should pass checkdoc, elint (with reason), and
       byte-compile with no warnings and errors
     - the following modules should be minimally feature complete:
       - files
	 - loading all, loading a non-opened file belonging to
	   project, specifying files explicitly in the configuration,
	   interactive function to add a file (buffer) to the project,
	   interactive function to remove current buffer from the
           project, add file to project, remove file from project
       - magit
	 - magit buffer for project
       - project-buffer-mode
	 - create and switch to project buffer mode
	 - as integrated with the latest pbm as possible (opening
           files from the buffer has the appropriate data set up, etc)
       - ido
	 - appropriate wrappers for opening files, switching buffers
     - Metaproject minor mode properly implemented
     - Appropriate key bindings should be set for all major add-in
       functions.
     - Enough functionality that users can create and configure
       projects by at least calling a series of functions in their
       *scratch* buffers, with no hand editing of .metaproject files
       required.
     - A quick intro for using it should be in the documentation.

   Releasing:
   - tag on github and update the github project page
   - make page on emacswiki and update
   - make page on freshmeat and update
   - announce to gnu.emacs.sources
   - tweet!
   - post announcement to my blog
   - create new branch in git for the <next version>-SNAPSHOT

   Future non-code things to do:
   - short screencast showcasing functionality
   - contact Emacs hacker friends asking for feedback, realizing they
     are all very busy

   I should spend a few minutes each day brainstorming about upcoming
   desirable features, potential issues to research, and future plans.

   A few quick ideas that should be elaborated on later:
   - a project management menu that is similar (perhaps) to the org
     agenda menu showing all available functions for a project.  this
     could be considered the "main project window" and is always open
     for a project while it is open.
     - Actually, I need to think about this as the registration
       functions are written and configuration is loaded.  What is
       lacking, if anything, to generate this menu for project?
   - a combined switch or open buffer function for files
   - should I make a "core" or "metaproject" default module and
     have associated configuration and state stored there or just
     continue to have some top-level state and configuration mixed in
     with module state and configuration?  Should probably be decided
     before the 0.2 release before I get users.
   - if interactive functions that are bound to a project are called
     outside of a project (via M-x) I should probably prompt for an
     open project to call the function on.
   - dired functions for adding files to a project
   - include/exclude/wildcard functionality for specifying files that
     are in a project
   - clean up project-utils similar to what is in magit so that it is
     a lot faster
   - a fancy project creation and configuration wizard [definitely
     long-term plans]

   That's enough brainstorming for one night.  Don't want to get
   myself overwhelmed.  It looks like for a solid 0.2 release, it will
   take at least another week or so of work.  I *might* be able to
   start dog-fooding tomorrow, though likely in a couple of days.

   One last one:
   - what can I automate?
   - and what about automated testing, perhaps like the Baseline
     framework?

** [2009-08-16 Sun 11:19]

   Notes about the 'files' module:
   - since there will eventually be more ways of specifying what files
     to include other than all explicitly, the list of files in the
     project should be stored in the state.  When the files key is
     used in the config, that list should be just copied to the state.
   - there should be 're-scan' functionality that will scan the
     filesystem to pick up new files if more than just the files key
     is used.
   - since the re-scan can be an expensive operation, I'm not sure
     that it makes sense to automatically do it before any file
     operation that is intended for more than just the currently open
     files.  at the very least, it should be something that the user
     can trigger.  should look at ways to do this while emacs is semi
     idle and how to break if up so it can be done asynchronously
     without blocking emacs
   - the rescan should be run automatically, however -- or at least
     prompted to do so -- when anything that affects what files are
     included are changed, i.e. adding or removing include/exclude
     patterns
   - whenever functions to add new files or remove files from the
     files key are called, this operation should happen on both the
     state and the config
   - as files are opened and closed, the state of the files module
     needs to be updated as well as the project state for buffers
   - files specific state needed:
     - all-files-list
     - open-files
   - files potential configuration items and defaults if appropriate
     - autoload - nil
     - all-files-list - nil
     - include-files-regexps - nil
     - exclude-files-regexps - nil

   Other notes:
   - when is the appropriate time to return defaults for state and
     config values for a module?
     - when loading from saved project, only want defaults if
       configuration exists for the module at all
     - want the defaults when adding configuration for the first
       time
     - want the defaults for state whenever configuration for the
       module exists.  state should always be created / accessed after
       configuration exists (at least defaults for configuration), so
       this is a decent metric
   - what follows the principle of least astonishment best?
     auto-saving the configuration every time a change is made?  Or
     saving it only when the user specifies?
     - the Gnome people have gone to having configuration dialogs
       auto-apply and then use undo functionality to go back.  would
       adding undo functionality make sense in this regard?
   - create a Makefile for common operations -- byte compiling,
     testing, etc.
   - test with both Emacs 23 and Emacs 22
     - update run-test.sh to do so
     - make sure that any necessary 23isms (new features, not API
       changes) are optional, with API changes, call backwards
       compatible versions
   - function naming convention
     - metaproject-<module name>-<verb>-<subject>-[modifier]

   Random future feature ideas:
   - support a narrow to subproject function for many operations,
     triggered by using C-u
     - only consider files from a subdirectory
     - only consider files of a certain type
       - major mode
       - extension
     - again, sounds like a great thing to implement in a wrapper that
       then passes the necessary info off to the desired function
     - useful for:
       - switching buffers
       - ibuffer
       - project-buffer-mode
       - opening files
       - opening un-opened file
       - closing files
   - add support for temporarily attaching a buffer to a project
   - a shortcut keys module for setting project or mode specific
     shortcut keys on a project-to-project basis.  Examples:
     - running checkdoc, elint, launching certain make targets

* Notes and plans:
** Open project
***  open all files in a project, including project supporting buffers
***  open just project supporting buffers, including:
**** magit status buffer
**** dired at top level dir
**** supporting org-mode file, if defined
**** open shell buffer (ansi-term or eshell) at top-level dir
**** websites to open via browse-url
***  run any project initialization commands, i.e.:
**** open rope project at appropriate dir (top-level?)
**** start SLIME

** Close project
***  Close all associated files and buffers

** Open file in project
***  Methods:
**** ido
**** dired or dired-like
**** speedbar
***  Use defined list of files in project
***  Use all files in project directories
***  Use all files in project directories sans those ignored by git (see git-dired.el)

** Open project among known projects (like magit-status-repos)

** DONE Switch to open project buffer (ido)
   CLOSED: [2009-08-12 Wed 04:15]

** Jump to or open project buffer:
***  magit status
***  dired (top-level, parent, current)
***  org-mode file
***  shell buffer
***  speedbar or dired for all project files

** Add a keyboard sub-map for the buffers in the project that adds:
***  open file in project
*** DONE close project
    CLOSED: [2009-08-12 Wed 04:15]
***  jump to or open project buffer
*** DONE switch to open project buffer
    CLOSED: [2009-08-12 Wed 04:15]

** Refresh project
***  if new files are added to project

** Add file to project
***  current buffer's file
***  prompt for file
***  currently marked file(s) in dired

** Remove file from project
***  current file
***  prompt for file (ido)

** Create empty project

** Grep through files of the project

** Etags

** ibuffer limited to just project files

** compile project

** agenda just for project files

** project-specific bookmarks

** create and elscreen session for the project

** questions:
*** I seem to be limiting the idea of a project of those files under a common sub-directory.
    This might be fine for now, but that doesn't seem to be a reasonable
    limitation.  I should examine where this assumption is made and see
    how to remove it.  i.e., metaproject-get-top-dir

*** It is probably a reasonable assumption that a given file can only
    belong to one open project at a time.  If I want to allow for this,
    how to work around it?

* Todos
** action registry
***  each key in the .metaproject plist is associated with a given
     action
***  these actions are provided by calling a registry function, often
     within an individual emacs module.  this allows for optional
     functionality to be provided and have a minimal stable core
***  at open time, the action registry is looped through, in order
     (should order matter?), and a check is made to see if a
     corresponding value is found in the plist.  if so, the registered
     action function is called with the value in the plist as its
     argument.
***  do I need registration for other events?  probably at least open
     and close.
***  only the basic ones that include default features from emacs
     proper will be included in the core metaproject module.  right
     now, this is simple file opening and closing and perhaps dired.
***  others include: magit, rope, slime, org-mode, shell buffer, etags
*** DONE Add magit buffer to buffer list and project to its local vars
    CLOSED: [2009-05-19 Tue 21:48]

** code clean-up
*** DONE convert the var to a defcustom
    CLOSED: [2009-05-01 Fri 16:33]
*** TODO add docstrings to all "top-level" functions, at minimum
*** DONE convert TODOs and the like from README.markdown to an org-mode file
    CLOSED: [2009-04-29 Wed 16:48]
*** TODO Add descriptions to the top of the .el files
*** TODO Add usage instructions
*** TODO run checkdoc and fix any errors it reports
